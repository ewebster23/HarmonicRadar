<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Harmonic Radar Games</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cabin+Sketch:wght@700&family=Kalam:wght@700&family=Patrick+Hand&display=swap');

    @font-face {
      font-family: "Finale Jazz Text";
      src: local("Finale Jazz Text"), local("FinaleJazzText"), url("fonts/FinaleJazzText.otf?v=20260219") format("opentype");
      font-display: swap;
    }

    @font-face {
      font-family: "Finale Jazz";
      src: local("Finale Jazz"), local("FinaleJazz"), url("fonts/FinaleJazz.otf?v=20260219") format("opentype");
      font-display: swap;
    }

    :root {
      color-scheme: light;
      --paper: #fff8e8;
      --paper-shadow: #f4e5c8;
      --ink: #2d3340;
      --ink-soft: #565f70;
      --line: #e4d1ab;
      --line-strong: #d1b783;
      --accent: #d47b2e;
      --accent-deep: #9d5118;
      --ok: #1f8f59;
      --warn: #a95c1d;
      --jazz-text: "Finale Jazz Text", "Finale Jazz", "Bravura Text", "Noto Music", serif;
      --chord-text: "Cabin Sketch", "Kalam", "Patrick Hand", sans-serif;
      --jazz-music: "Finale Jazz", "Finale Jazz Text", "Bravura Text", "Noto Music", serif;
    }

    * { box-sizing: border-box; }

    html,
    body {
      width: 100%;
      height: 100%;
    }

    body {
      margin: 0;
      font-family: var(--jazz-text);
      color: var(--ink);
      background: var(--paper);
      overflow: hidden;
      position: relative;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0.24;
      background:
        repeating-linear-gradient(
          to bottom,
          transparent 0,
          transparent 19px,
          rgba(130, 150, 173, 0.15) 19px,
          rgba(130, 150, 173, 0.15) 20px
        );
    }

    .home-toggle {
      position: fixed;
      top: 0.65rem;
      left: 0.72rem;
      z-index: 34;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 2px solid rgba(76, 59, 30, 0.48);
      border-radius: 999px;
      height: 52px;
      min-width: 88px;
      padding: 0 0.9rem;
      font-size: 1.03rem;
      line-height: 1;
      text-decoration: none;
      color: #7b4b1f;
      background: #fff8ef;
      box-shadow: 0 2px 0 rgba(76, 59, 30, 0.25);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .home-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 0 rgba(76, 59, 30, 0.26);
    }

    .settings-toggle {
      position: fixed;
      top: 0.65rem;
      right: 0.72rem;
      z-index: 34;
      width: 52px;
      height: 52px;
      border-radius: 999px;
      border: 2px solid rgba(76, 59, 30, 0.48);
      font-size: 1.62rem;
      line-height: 1;
      font-family: var(--jazz-text);
      color: #7b4b1f;
      background: #fff8ef;
      cursor: pointer;
      box-shadow: 0 2px 0 rgba(76, 59, 30, 0.25);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .settings-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 0 rgba(76, 59, 30, 0.26);
    }

    .settings-backdrop {
      position: fixed;
      inset: 0;
      z-index: 30;
      background: rgba(38, 47, 62, 0.28);
    }

    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      z-index: 35;
      width: min(350px, 90vw);
      height: 100dvh;
      padding: 1rem 0.9rem 0.95rem;
      background: var(--paper);
      border-left: 2px dashed var(--line-strong);
      box-shadow: -12px 0 28px rgba(48, 55, 72, 0.12);
      transform: translateX(104%);
      transition: transform 180ms ease;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 0.7rem;
      overflow: hidden;
    }

    .settings-panel.open {
      transform: translateX(0);
    }

    .settings-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.4rem;
    }

    .settings-title {
      margin: 0;
      font-size: 1.55rem;
      letter-spacing: 0.01em;
      color: #22314a;
    }

    .settings-close {
      border: 1px solid rgba(46, 31, 8, 0.42);
      border-radius: 999px;
      background: #fff8ef;
      color: #4d5f77;
      width: 34px;
      height: 34px;
      font-size: 1.1rem;
      line-height: 1;
      font-family: var(--jazz-text);
      cursor: pointer;
    }

    .settings-body {
      min-height: 0;
      overflow: auto;
      display: grid;
      align-content: start;
      gap: 0.65rem;
    }

    .connect-btn {
      justify-self: start;
      border: 1px solid rgba(46, 31, 8, 0.45);
      border-radius: 999px;
      padding: 0.34rem 0.72rem;
      font-size: 0.95rem;
      font-family: var(--jazz-text);
      font-weight: 700;
      color: #fff;
      background: linear-gradient(145deg, var(--accent), var(--accent-deep));
      cursor: pointer;
      box-shadow: 0 2px 0 rgba(30, 19, 4, 0.25);
    }

    .connect-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .status {
      font-size: 0.95rem;
      font-weight: 700;
    }

    .status.ok { color: var(--ok); }
    .status.warn { color: var(--warn); }

    .midi-info {
      margin: 0;
      font-size: 0.9rem;
      color: var(--ink-soft);
      line-height: 1.25;
    }

    .sound-setting {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.16rem 0;
    }

    .sound-label {
      font-size: 0.93rem;
      color: #3d4b63;
    }

    .sound-toggle {
      width: 18px;
      height: 18px;
      accent-color: #8f531f;
      cursor: pointer;
    }

    .inputs-label {
      font-size: 0.92rem;
      color: #4e5e75;
      margin-bottom: 0.1rem;
    }

    .inputs {
      margin: 0;
      padding-left: 1rem;
      font-size: 0.86rem;
      line-height: 1.2;
      color: var(--ink-soft);
      max-height: 34vh;
      overflow: auto;
    }

    .game-app {
      width: 100vw;
      height: 100dvh;
      display: grid;
      grid-template-rows: 1fr auto;
      gap: 0.06rem;
      padding: 0.5rem 0.8rem 0.28rem;
    }

    .score-area {
      min-height: 0;
      width: min(1460px, 100%);
      margin: 0 auto;
      display: grid;
      grid-template-rows: auto auto auto;
      align-content: end;
      justify-items: center;
      gap: 0.1rem;
      overflow: hidden;
      padding-top: 0.12rem;
    }

    .game-title {
      font-family: var(--chord-text);
      font-size: clamp(2rem, 4.6vw, 3.6rem);
      line-height: 0.92;
      color: #1f2e47;
      margin-bottom: -0.3rem;
      text-align: center;
    }

    .prompt {
      margin: 0;
      font-size: clamp(1.05rem, 2vw, 1.35rem);
      color: #3a4e6d;
      text-align: center;
    }

    .staff-wrap {
      min-height: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      width: min(100%, 1300px);
      border-radius: 14px;
      transition: box-shadow 140ms ease, background 140ms ease;
    }

    .staff-wrap.result-neutral {
      box-shadow: inset 0 0 0 1px rgba(119, 102, 70, 0.16);
      background: rgba(255, 248, 232, 0.5);
    }

    .staff-wrap.result-good {
      box-shadow: inset 0 0 0 2px rgba(20, 138, 65, 0.72);
      background: rgba(206, 252, 224, 0.78);
    }

    .staff-wrap.result-bad {
      box-shadow: inset 0 0 0 2px rgba(179, 18, 23, 0.78);
      background: rgba(255, 215, 219, 0.82);
    }

    .staff-canvas {
      width: 100%;
      height: auto;
      display: block;
      background: var(--paper);
      border: 0;
    }

    .hud {
      margin-top: -0.25rem;
      text-align: center;
      display: grid;
      gap: 0.12rem;
    }

    .feedback {
      margin: 0;
      font-size: clamp(1rem, 2vw, 1.2rem);
      color: #2f4260;
      min-height: 1.3em;
      border-radius: 999px;
      padding: 0.1rem 0.65rem;
      justify-self: center;
    }

    .feedback.state-neutral {
      color: #2f4260;
      background: rgba(228, 215, 188, 0.45);
    }

    .feedback.state-good {
      color: #0f6a33;
      background: rgba(194, 250, 216, 0.95);
    }

    .feedback.state-bad {
      color: #97191e;
      background: rgba(255, 209, 216, 0.97);
    }

    .stats,
    .last-note {
      margin: 0;
      font-size: clamp(0.92rem, 1.85vw, 1.05rem);
      color: #53627a;
    }

    .next-btn {
      justify-self: center;
      border: 2px solid rgba(49, 31, 6, 0.42);
      border-radius: 999px;
      padding: 0.4rem 1.04rem;
      font-size: clamp(0.95rem, 1.8vw, 1.1rem);
      font-family: var(--jazz-text);
      font-weight: 700;
      color: #fff;
      background: linear-gradient(145deg, var(--accent), var(--accent-deep));
      box-shadow: 0 2px 0 rgba(45, 26, 4, 0.3);
      cursor: pointer;
    }

    .keyboard-row {
      margin-left: calc(50% - 50vw);
      margin-right: calc(50% - 50vw);
      border-top: 1px dashed var(--line-strong);
      padding-top: 0.08rem;
    }

    .keyboard-canvas {
      width: 100vw;
      height: auto;
      display: block;
      background: var(--paper);
      border-top: 1px solid var(--paper-shadow);
    }

    @media (max-width: 1080px) {
      body {
        overflow-y: auto;
      }

      .game-app {
        height: auto;
        min-height: 100dvh;
        padding-right: 0.45rem;
        padding-left: 0.45rem;
      }

      .keyboard-row {
        margin: 0;
      }

      .keyboard-canvas {
        width: 100%;
      }

      .settings-toggle {
        width: 46px;
        height: 46px;
        font-size: 1.45rem;
      }

      .home-toggle {
        height: 46px;
        min-width: 78px;
        font-size: 0.95rem;
      }
    }

  </style>
</head>
<body>
  <a class="home-toggle" href="./index.html" aria-label="Back to home">Home</a>
  <button id="settingsToggle" class="settings-toggle" aria-label="Open settings">âš™</button>
  <div id="settingsBackdrop" class="settings-backdrop" hidden></div>

  <aside id="settingsPanel" class="settings-panel" aria-hidden="true">
    <div class="settings-head">
      <h2 class="settings-title">Settings</h2>
      <button id="settingsClose" class="settings-close" type="button" aria-label="Close settings">âœ•</button>
    </div>

    <div class="settings-body">
      <button id="connectBtn" class="connect-btn" type="button">Connect MIDI</button>
      <div id="status" class="status warn">Not connected</div>
      <p id="midiInfo" class="midi-info">Laptop keyboard is active.</p>

      <div class="sound-setting">
        <label class="sound-label" for="typingSoundToggle">Toggle Sound</label>
        <input id="typingSoundToggle" class="sound-toggle" type="checkbox" />
      </div>

      <div>
        <div class="inputs-label">MIDI inputs</div>
        <ul id="inputsList" class="inputs">
          <li>Not connected.</li>
        </ul>
      </div>
    </div>
  </aside>

  <main class="game-app">
    <section class="score-area">
      <div class="game-title">Note Hunter</div>
      <p class="prompt">Play the note shown on the staff (MIDI, laptop keys, or on-screen keyboard)</p>
      <div id="staffWrap" class="staff-wrap result-neutral">
        <canvas id="staffCanvas" class="staff-canvas" width="1360" height="460"></canvas>
      </div>
      <div class="hud">
        <p id="feedback" class="feedback state-neutral">Play a note to answer.</p>
        <p id="stats" class="stats">Score: 0 | Streak: 0 | Attempts: 0</p>
        <p id="lastNote" class="last-note">Last played: none</p>
        <button id="nextBtn" class="next-btn" type="button">Skip / Next Note</button>
      </div>
    </section>

    <section class="keyboard-row">
      <canvas id="keyboardCanvas" class="keyboard-canvas" width="1920" height="168"></canvas>
    </section>
  </main>

  <script>
    const connectBtn = document.getElementById('connectBtn');
    const statusEl = document.getElementById('status');
    const midiInfoEl = document.getElementById('midiInfo');
    const settingsToggleEl = document.getElementById('settingsToggle');
    const settingsPanelEl = document.getElementById('settingsPanel');
    const settingsCloseEl = document.getElementById('settingsClose');
    const settingsBackdropEl = document.getElementById('settingsBackdrop');
    const typingSoundToggleEl = document.getElementById('typingSoundToggle');
    const inputsListEl = document.getElementById('inputsList');
    const staffCanvasEl = document.getElementById('staffCanvas');
    const staffWrapEl = document.getElementById('staffWrap');
    const keyboardCanvasEl = document.getElementById('keyboardCanvas');
    const feedbackEl = document.getElementById('feedback');
    const statsEl = document.getElementById('stats');
    const lastNoteEl = document.getElementById('lastNote');
    const nextBtnEl = document.getElementById('nextBtn');

    const NOTE_LABELS = ['C', 'Dâ™­', 'D', 'Eâ™­', 'E', 'F', 'Fâ™¯', 'G', 'Aâ™­', 'A', 'Bâ™­', 'B'];
    const WHITE_PITCH_CLASSES = new Set([0, 2, 4, 5, 7, 9, 11]);
    const JAZZ_TEXT_FONT_STACK = '"Finale Jazz Text","Finale Jazz","Bravura Text","Noto Music",serif';
    const JAZZ_MUSIC_FONT_STACK = '"Finale Jazz","Finale Jazz Text","Bravura Text","Noto Music",serif';
    const COMPUTER_KEY_SEQUENCE = ['a', 'w', 's', 'e', 'd', 'f', 't', 'g', 'y', 'h', 'u', 'j', 'k', 'o', 'l', 'p'];
    const COMPUTER_KEY_BASE_NOTE = 60; // C4
    const KEYBOARD_NOTE_START = 36; // C2
    const KEYBOARD_NOTE_END = 96; // C7
    const MOBILE_KEYBOARD_NOTE_START = 60; // C4
    const MOBILE_KEYBOARD_NOTE_END = 72; // C5
    const AUTO_NEXT_DELAY_MS = 900;
    const STAFF_STEP_MAP = {
      0: { stepOffset: 0, accidental: '' }, // C
      1: { stepOffset: 1, accidental: 'â™­' }, // Dâ™­
      2: { stepOffset: 1, accidental: '' }, // D
      3: { stepOffset: 2, accidental: 'â™­' }, // Eâ™­
      4: { stepOffset: 2, accidental: '' }, // E
      5: { stepOffset: 3, accidental: '' }, // F
      6: { stepOffset: 3, accidental: 'â™¯' }, // Fâ™¯
      7: { stepOffset: 4, accidental: '' }, // G
      8: { stepOffset: 5, accidental: 'â™­' }, // Aâ™­
      9: { stepOffset: 5, accidental: '' }, // A
      10: { stepOffset: 6, accidental: 'â™­' }, // Bâ™­
      11: { stepOffset: 6, accidental: '' } // B
    };

    const NOTE_POOL = [
      { midi: 60, name: 'C4', step: -2 },
      { midi: 62, name: 'D4', step: -1 },
      { midi: 64, name: 'E4', step: 0 },
      { midi: 65, name: 'F4', step: 1 },
      { midi: 67, name: 'G4', step: 2 },
      { midi: 69, name: 'A4', step: 3 },
      { midi: 71, name: 'B4', step: 4 },
      { midi: 72, name: 'C5', step: 5 },
      { midi: 74, name: 'D5', step: 6 }
    ];

    let midiAccess = null;
    const noteCounts = new Map();
    const heldComputerKeys = new Set();
    const computerKeyToNote = new Map(
      COMPUTER_KEY_SEQUENCE.map((key, index) => [key, COMPUTER_KEY_BASE_NOTE + index])
    );
    const noteToComputerKey = new Map(
      [...computerKeyToNote.entries()].map(([key, noteNumber]) => [noteNumber, key.toUpperCase()])
    );
    const activePointerNotes = new Map();

    let typingSoundEnabled = false;
    let audioContext = null;
    const activeTypingVoices = new Map();

    let score = 0;
    let streak = 0;
    let attempts = 0;
    let currentTarget = null;
    let solvedTarget = false;
    let lastPlayedName = 'none';
    let lastGuessedNoteNumber = null;
    let feedbackState = 'neutral';
    let autoNextTimerId = null;
    let musicFontReady = false;

    function normalizePitchClass(value) {
      return ((value % 12) + 12) % 12;
    }

    function labelPitchClass(pitchClass) {
      return NOTE_LABELS[normalizePitchClass(pitchClass)];
    }

    function midiNoteToName(noteNumber) {
      const pitchName = labelPitchClass(noteNumber);
      const octave = Math.floor(noteNumber / 12) - 1;
      return `${pitchName}${octave}`;
    }

    function isBlackKey(noteNumber) {
      return !WHITE_PITCH_CLASSES.has(normalizePitchClass(noteNumber));
    }

    function getKeyboardNoteRange() {
      if (
        typeof window !== 'undefined'
        && typeof window.matchMedia === 'function'
        && window.matchMedia('(max-width: 760px)').matches
      ) {
        return {
          start: MOBILE_KEYBOARD_NOTE_START,
          end: MOBILE_KEYBOARD_NOTE_END
        };
      }

      return {
        start: KEYBOARD_NOTE_START,
        end: KEYBOARD_NOTE_END
      };
    }

    function resizeCanvasForDisplay(canvas) {
      if (!canvas) {
        return;
      }
      const ratio = window.devicePixelRatio || 1;
      const width = Math.max(1, Math.floor(canvas.clientWidth * ratio));
      const height = Math.max(1, Math.floor(canvas.clientHeight * ratio));
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
    }

    function setStatus(text, ok = false) {
      statusEl.textContent = text;
      statusEl.classList.toggle('ok', ok);
      statusEl.classList.toggle('warn', !ok);
    }

    function setMidiInfo(text) {
      midiInfoEl.textContent = text;
    }

    function getSortedActiveNotes() {
      return [...noteCounts.keys()].sort((a, b) => a - b);
    }

    function updateStats() {
      statsEl.textContent = `Score: ${score} | Streak: ${streak} | Attempts: ${attempts}`;
    }

    function updateLastPlayed(text) {
      lastPlayedName = text;
      lastNoteEl.textContent = `Last played: ${lastPlayedName}`;
    }

    function clearAutoNextTimer() {
      if (autoNextTimerId !== null) {
        window.clearTimeout(autoNextTimerId);
        autoNextTimerId = null;
      }
    }

    function setFeedback(text, state = 'neutral') {
      feedbackState = state;
      feedbackEl.textContent = text;
      feedbackEl.classList.remove('state-neutral', 'state-good', 'state-bad');
      feedbackEl.classList.add(`state-${state}`);

      if (staffWrapEl) {
        staffWrapEl.classList.remove('result-neutral', 'result-good', 'result-bad');
        staffWrapEl.classList.add(`result-${state}`);
      }
    }

    function midiNoteToStaffData(noteNumber) {
      const pitchClass = normalizePitchClass(noteNumber);
      const octave = Math.floor(noteNumber / 12) - 1;
      const map = STAFF_STEP_MAP[pitchClass];
      // Treble-only staff baseline is E4 on the bottom line.
      const step = (octave - 4) * 7 + map.stepOffset - 2;
      return { step, accidental: map.accidental };
    }

    function pickNextTarget() {
      clearAutoNextTimer();
      const pool = currentTarget
        ? NOTE_POOL.filter((note) => note.midi !== currentTarget.midi)
        : NOTE_POOL;
      currentTarget = pool[Math.floor(Math.random() * pool.length)];
      solvedTarget = false;
      lastGuessedNoteNumber = null;
      setFeedback('Play a note to answer.', 'neutral');
      drawStaff();
    }

    function evaluateGuess(noteNumber) {
      if (!currentTarget || solvedTarget) {
        return;
      }

      attempts += 1;
      const playedName = midiNoteToName(noteNumber);
      lastGuessedNoteNumber = noteNumber;
      updateLastPlayed(playedName);

      if (normalizePitchClass(noteNumber) === normalizePitchClass(currentTarget.midi)) {
        solvedTarget = true;
        score += 1;
        streak += 1;
        setFeedback(`Correct: ${playedName}. Next note...`, 'good');
        updateStats();
        clearAutoNextTimer();
        autoNextTimerId = window.setTimeout(() => {
          autoNextTimerId = null;
          nextRound();
        }, AUTO_NEXT_DELAY_MS);
        return;
      }

      streak = 0;
      setFeedback(`Nope. You played ${playedName}. Try again.`, 'bad');
      updateStats();
    }

    function incrementNote(noteNumber) {
      const current = noteCounts.get(noteNumber) || 0;
      noteCounts.set(noteNumber, current + 1);
    }

    function decrementNote(noteNumber) {
      const current = noteCounts.get(noteNumber);
      if (!current) {
        return;
      }
      if (current <= 1) {
        noteCounts.delete(noteNumber);
        return;
      }
      noteCounts.set(noteNumber, current - 1);
    }

    function ensureAudioContext() {
      const AudioCtor = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtor) {
        return null;
      }
      if (!audioContext) {
        audioContext = new AudioCtor();
      }
      return audioContext;
    }

    function midiNoteToFrequency(noteNumber) {
      return 440 * Math.pow(2, (noteNumber - 69) / 12);
    }

    function startTypingSound(noteNumber) {
      if (!typingSoundEnabled || activeTypingVoices.has(noteNumber)) {
        return;
      }
      const ctx = ensureAudioContext();
      if (!ctx) {
        return;
      }
      if (ctx.state === 'suspended') {
        ctx.resume().catch(() => {});
      }

      const now = ctx.currentTime;
      const oscillator = ctx.createOscillator();
      const gainNode = ctx.createGain();
      oscillator.type = 'triangle';
      oscillator.frequency.setValueAtTime(midiNoteToFrequency(noteNumber), now);
      gainNode.gain.setValueAtTime(0.0001, now);
      gainNode.gain.exponentialRampToValueAtTime(0.06, now + 0.02);
      gainNode.gain.exponentialRampToValueAtTime(0.045, now + 0.09);
      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);
      oscillator.start(now);
      activeTypingVoices.set(noteNumber, { oscillator, gainNode });
    }

    function stopTypingSound(noteNumber) {
      const voice = activeTypingVoices.get(noteNumber);
      if (!voice) {
        return;
      }
      const ctx = ensureAudioContext();
      if (!ctx) {
        activeTypingVoices.delete(noteNumber);
        return;
      }

      const now = ctx.currentTime;
      const currentGain = Math.max(voice.gainNode.gain.value, 0.0001);
      voice.gainNode.gain.cancelScheduledValues(now);
      voice.gainNode.gain.setValueAtTime(currentGain, now);
      voice.gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.085);
      voice.oscillator.stop(now + 0.095);
      voice.oscillator.onended = () => {
        voice.oscillator.disconnect();
        voice.gainNode.disconnect();
      };
      activeTypingVoices.delete(noteNumber);
    }

    function stopAllTypingSound() {
      for (const noteNumber of [...activeTypingVoices.keys()]) {
        stopTypingSound(noteNumber);
      }
    }

    function setTypingSoundEnabled(enabled) {
      typingSoundEnabled = enabled;
      if (!enabled) {
        stopAllTypingSound();
      }
    }

    function pseudoRandom(seed) {
      const value = Math.sin(seed * 12.9898) * 43758.5453123;
      return value - Math.floor(value);
    }

    function drawSketchLine(ctx, x1, y1, x2, y2, seed) {
      const midX = (x1 + x2) / 2;
      const wobble = (pseudoRandom(seed) - 0.5) * 2.1;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.quadraticCurveTo(midX, y1 + wobble, x2, y2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x1 + 0.35, y1 + 0.18);
      ctx.quadraticCurveTo(midX + 0.25, y1 + wobble + 0.2, x2 - 0.35, y2 + 0.14);
      ctx.stroke();
    }

    function drawSketchRect(ctx, x, y, width, height, seed) {
      const wobble = (pseudoRandom(seed) - 0.5) * 0.9;
      ctx.beginPath();
      ctx.moveTo(x, y + wobble);
      ctx.lineTo(x + width, y - wobble);
      ctx.lineTo(x + width + wobble, y + height);
      ctx.lineTo(x - wobble, y + height + wobble);
      ctx.closePath();
      ctx.stroke();
    }

    function drawFinaleWholeNote(ctx, x, y, ratio, colors = null) {
      const strokeColor = colors && colors.stroke ? colors.stroke : '#233247';
      const fillColor = colors && colors.fill ? colors.fill : strokeColor;
      const glyph = '\uE0A2'; // SMuFL whole-note notehead
      const fontSize = 56 * ratio;

      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${fontSize}px ${JAZZ_MUSIC_FONT_STACK}`;
      ctx.fillStyle = fillColor;
      ctx.fillText(glyph, x, y);
      ctx.restore();
    }

    function drawFallbackWholeNote(ctx, x, y, ratio, colors = null) {
      const strokeColor = colors && colors.stroke ? colors.stroke : '#233247';
      const fillColor = colors && colors.fill ? colors.fill : '#fff7ea';
      const rx = 12.0 * ratio;
      const ry = 8.4 * ratio;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(-0.28);
      ctx.strokeStyle = strokeColor;
      ctx.fillStyle = fillColor;
      ctx.lineWidth = 1.6 * ratio;
      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function drawWholeNote(ctx, x, y, ratio, colors = null) {
      if (musicFontReady) {
        drawFinaleWholeNote(ctx, x, y, ratio, colors);
        return;
      }
      drawFallbackWholeNote(ctx, x, y, ratio, colors);
    }

    function refreshMusicFontReady() {
      if (!document.fonts || typeof document.fonts.check !== 'function') {
        musicFontReady = true;
        return;
      }
      musicFontReady = document.fonts.check('64px "Finale Jazz"', '\uE050');
    }

    function primeMusicFonts() {
      refreshMusicFontReady();
      if (musicFontReady || !document.fonts || typeof document.fonts.load !== 'function') {
        return;
      }

      Promise.all([
        document.fonts.load('64px "Finale Jazz"', '\uE050')
      ]).then(() => {
        refreshMusicFontReady();
        renderVisuals();
      }).catch(() => {});

      if (typeof document.fonts.ready?.then === 'function') {
        document.fonts.ready.then(() => {
          refreshMusicFontReady();
          renderVisuals();
        }).catch(() => {});
      }
    }

    function drawStaff() {
      if (!staffCanvasEl || !currentTarget) {
        return;
      }

      resizeCanvasForDisplay(staffCanvasEl);
      const ctx = staffCanvasEl.getContext('2d');
      if (!ctx) {
        return;
      }

      const ratio = window.devicePixelRatio || 1;
      const width = staffCanvasEl.width;
      const height = staffCanvasEl.height;
      ctx.clearRect(0, 0, width, height);

      ctx.fillStyle = '#fff8eb';
      ctx.fillRect(0, 0, width, height);

      const marginX = Math.round(68 * ratio);
      const left = marginX;
      const right = width - marginX;
      const stepHeight = 12.4 * ratio;
      const bottomLineY = height * 0.66;
      const lineSteps = [0, 2, 4, 6, 8];
      const noteX = Math.round((left + right) * 0.56);
      const clefX = left + 30 * ratio;
      const clefY = bottomLineY - 4 * stepHeight;
      const targetStaff = midiNoteToStaffData(currentTarget.midi);
      const targetY = bottomLineY - targetStaff.step * stepHeight;
      const playedStaff = typeof lastGuessedNoteNumber === 'number'
        ? midiNoteToStaffData(lastGuessedNoteNumber)
        : null;

      ctx.strokeStyle = '#6f7d90';
      ctx.lineWidth = 1.4 * ratio;
      for (const step of lineSteps) {
        const y = bottomLineY - step * stepHeight;
        drawSketchLine(ctx, left, y, right, y, y * 0.019 + step);
      }

      ctx.fillStyle = '#2f4057';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${76 * ratio}px ${JAZZ_MUSIC_FONT_STACK}`;
      ctx.fillText(musicFontReady ? '\uE050' : 'ð„ž', clefX, clefY);

      const noteInfos = [{ step: targetStaff.step }];
      if (playedStaff) {
        noteInfos.push({ step: playedStaff.step });
      }

      const uniqueSteps = [...new Set(noteInfos.map((info) => info.step))];

      for (const step of uniqueSteps) {
        if (step < 0) {
          for (let s = -2; s >= step; s -= 2) {
            const y = bottomLineY - s * stepHeight;
            drawSketchLine(ctx, noteX - 12 * ratio, y, noteX + 12 * ratio, y, s + noteX * 0.01);
          }
        }
      }

      for (const step of uniqueSteps) {
        if (step > 8) {
          for (let s = 10; s <= step; s += 2) {
            const y = bottomLineY - s * stepHeight;
            drawSketchLine(ctx, noteX - 12 * ratio, y, noteX + 12 * ratio, y, s + noteX * 0.014);
          }
        }
      }

      if (targetStaff.accidental) {
        ctx.fillStyle = '#21324d';
        ctx.font = `${17 * ratio}px ${JAZZ_MUSIC_FONT_STACK}`;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillText(targetStaff.accidental, noteX - 16 * ratio, targetY + 1 * ratio);
      }

      drawWholeNote(
        ctx,
        noteX,
        targetY,
        ratio,
        { stroke: '#233247', fill: '#233247' }
      );

      if (playedStaff) {
        const playedY = bottomLineY - playedStaff.step * stepHeight;
        const playedStroke = feedbackState === 'good' ? '#148a41' : '#b31217';
        const playedFill = playedStroke;

        if (playedStaff.accidental) {
          ctx.fillStyle = playedStroke;
          ctx.font = `${17 * ratio}px ${JAZZ_MUSIC_FONT_STACK}`;
          ctx.textAlign = 'right';
          ctx.textBaseline = 'middle';
          ctx.fillText(playedStaff.accidental, noteX - 16 * ratio, playedY + 1 * ratio);
        }

        drawWholeNote(
          ctx,
          noteX,
          playedY,
          ratio,
          { stroke: playedStroke, fill: playedFill }
        );
      }

      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
    }

    function getWhiteKeyCount(start, end) {
      let count = 0;
      for (let note = start; note <= end; note += 1) {
        if (!isBlackKey(note)) {
          count += 1;
        }
      }
      return count;
    }

    function drawKeyboardTriggerLabel(ctx, text, centerX, centerY, ratio, blackTheme, seed) {
      ctx.save();
      ctx.font = `${10 * ratio}px ${JAZZ_TEXT_FONT_STACK}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const textWidth = ctx.measureText(text).width;
      const padX = 4 * ratio;
      const boxWidth = textWidth + padX * 2;
      const boxHeight = 12 * ratio;
      const boxX = centerX - boxWidth / 2;
      const boxY = centerY - boxHeight / 2;
      ctx.fillStyle = blackTheme ? 'rgba(255, 247, 230, 0.95)' : '#f4e2bf';
      ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
      ctx.strokeStyle = blackTheme ? '#ceb78f' : '#9a8768';
      ctx.lineWidth = 1;
      drawSketchRect(ctx, boxX, boxY, boxWidth, boxHeight, seed);
      ctx.fillStyle = blackTheme ? '#1a2636' : '#2e3d53';
      ctx.fillText(text, centerX, centerY + 0.3 * ratio);
      ctx.restore();
    }

    function drawKeyboard(activeNotes) {
      resizeCanvasForDisplay(keyboardCanvasEl);
      const ctx = keyboardCanvasEl.getContext('2d');
      if (!ctx) {
        return;
      }

      const ratio = window.devicePixelRatio || 1;
      const width = keyboardCanvasEl.width;
      const height = keyboardCanvasEl.height;
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#fff8eb';
      ctx.fillRect(0, 0, width, height);

      const { start: rangeStart, end: rangeEnd } = getKeyboardNoteRange();
      const whiteCount = getWhiteKeyCount(rangeStart, rangeEnd);
      const whiteWidth = width / whiteCount;
      const blackWidth = whiteWidth * 0.62;
      const blackHeight = height * 0.58;
      const activeSet = new Set(activeNotes);
      const keyLabelPositions = new Map();
      let whiteIndex = 0;

      for (let note = rangeStart; note <= rangeEnd; note += 1) {
        if (isBlackKey(note)) {
          continue;
        }

        const x = whiteIndex * whiteWidth;
        keyLabelPositions.set(note, { x: x + whiteWidth / 2 });
        ctx.fillStyle = activeSet.has(note) ? '#efbb6f' : '#fffdf7';
        ctx.fillRect(x, 0, whiteWidth, height);
        ctx.strokeStyle = '#8a7860';
        ctx.lineWidth = 1;
        drawSketchRect(ctx, x, 0, whiteWidth, height, note * 0.13);

        if (normalizePitchClass(note) === 0) {
          ctx.fillStyle = '#7c6a4d';
          ctx.font = `${9 * ratio}px ${JAZZ_TEXT_FONT_STACK}`;
          ctx.fillText(`C${Math.floor(note / 12) - 1}`, x + 2 * ratio, height - 6 * ratio);
        }

        const triggerKey = noteToComputerKey.get(note);
        if (triggerKey) {
          drawKeyboardTriggerLabel(ctx, triggerKey, x + whiteWidth / 2, height - 17 * ratio, ratio, false, note * 0.31);
        }

        whiteIndex += 1;
      }

      for (let note = rangeStart; note <= rangeEnd; note += 1) {
        if (!isBlackKey(note)) {
          continue;
        }

        const nextWhiteIndex = getWhiteKeyCount(rangeStart, note);
        const x = nextWhiteIndex * whiteWidth - blackWidth / 2;
        keyLabelPositions.set(note, { x: x + blackWidth / 2 });
        ctx.fillStyle = activeSet.has(note) ? '#de7a42' : '#1a2636';
        ctx.fillRect(x, 0, blackWidth, blackHeight);
        ctx.strokeStyle = '#131c2c';
        ctx.lineWidth = 1;
        drawSketchRect(ctx, x, 0, blackWidth, blackHeight, note * 0.17);

        const triggerKey = noteToComputerKey.get(note);
        if (triggerKey) {
          drawKeyboardTriggerLabel(ctx, triggerKey, x + blackWidth / 2, blackHeight - 12 * ratio, ratio, true, note * 0.39);
        }
      }

      if (!activeNotes.length) {
        return;
      }

      const labels = activeNotes
        .filter((note) => keyLabelPositions.has(note))
        .map((note) => ({ note, x: keyLabelPositions.get(note).x, text: midiNoteToName(note) }))
        .sort((left, right) => left.x - right.x);

      ctx.font = `${10 * ratio}px ${JAZZ_TEXT_FONT_STACK}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const minSpacing = 30 * ratio;
      let previousX = -Infinity;
      let previousRow = 0;

      for (const label of labels) {
        let row = 0;
        if (label.x - previousX < minSpacing) {
          row = Math.min(previousRow + 1, 2);
        }
        const y = (10 + row * 12) * ratio;
        const textWidth = ctx.measureText(label.text).width;
        const padX = 4 * ratio;
        const boxWidth = textWidth + padX * 2;
        const boxHeight = 12 * ratio;
        const boxX = label.x - boxWidth / 2;
        const boxY = y - boxHeight / 2;
        ctx.fillStyle = '#fff7e7';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = '#9c8b72';
        ctx.lineWidth = 1;
        drawSketchRect(ctx, boxX, boxY, boxWidth, boxHeight, label.note * 0.21);
        ctx.fillStyle = '#2c3a4f';
        ctx.fillText(label.text, label.x, y + 0.4 * ratio);
        previousX = label.x;
        previousRow = row;
      }
    }

    function renderVisuals() {
      drawStaff();
      drawKeyboard(getSortedActiveNotes());
    }

    function handleNoteOn(noteNumber) {
      incrementNote(noteNumber);
      evaluateGuess(noteNumber);
      startTypingSound(noteNumber);
      renderVisuals();
    }

    function handleNoteOff(noteNumber) {
      decrementNote(noteNumber);
      if (!noteCounts.has(noteNumber)) {
        stopTypingSound(noteNumber);
      }
      renderVisuals();
    }

    function getKeyboardCanvasPointFromEvent(event) {
      if (!keyboardCanvasEl || typeof keyboardCanvasEl.getBoundingClientRect !== 'function') {
        return null;
      }

      const rect = keyboardCanvasEl.getBoundingClientRect();
      if (!rect.width || !rect.height) {
        return null;
      }

      const x = (event.clientX - rect.left) * (keyboardCanvasEl.width / rect.width);
      const y = (event.clientY - rect.top) * (keyboardCanvasEl.height / rect.height);
      return { x, y };
    }

    function getKeyboardNoteFromCanvasPosition(x, y) {
      if (!keyboardCanvasEl) {
        return null;
      }

      const width = keyboardCanvasEl.width;
      const height = keyboardCanvasEl.height;
      if (x < 0 || x > width || y < 0 || y > height) {
        return null;
      }

      const { start: rangeStart, end: rangeEnd } = getKeyboardNoteRange();
      const whiteCount = getWhiteKeyCount(rangeStart, rangeEnd);
      const whiteWidth = width / whiteCount;
      const blackWidth = whiteWidth * 0.62;
      const blackHeight = height * 0.58;

      if (y <= blackHeight) {
        for (let note = rangeStart; note <= rangeEnd; note += 1) {
          if (!isBlackKey(note)) {
            continue;
          }
          const nextWhiteIndex = getWhiteKeyCount(rangeStart, note);
          const keyX = nextWhiteIndex * whiteWidth - blackWidth / 2;
          if (x >= keyX && x <= keyX + blackWidth) {
            return note;
          }
        }
      }

      let whiteIndex = 0;
      for (let note = rangeStart; note <= rangeEnd; note += 1) {
        if (isBlackKey(note)) {
          continue;
        }
        const keyX = whiteIndex * whiteWidth;
        if (x >= keyX && x <= keyX + whiteWidth) {
          return note;
        }
        whiteIndex += 1;
      }

      return null;
    }

    function setPointerNote(pointerId, nextNote) {
      const previousNote = activePointerNotes.get(pointerId);
      const prevIsNote = typeof previousNote === 'number';
      const nextIsNote = typeof nextNote === 'number';

      if (prevIsNote && nextIsNote && previousNote === nextNote) {
        return;
      }

      if (prevIsNote) {
        handleNoteOff(previousNote);
      }

      if (nextIsNote) {
        activePointerNotes.set(pointerId, nextNote);
        handleNoteOn(nextNote);
      } else {
        activePointerNotes.delete(pointerId);
      }
    }

    function releasePointerNote(pointerId) {
      if (!activePointerNotes.has(pointerId)) {
        return;
      }
      setPointerNote(pointerId, null);
    }

    function releasePointerNotes() {
      for (const pointerId of [...activePointerNotes.keys()]) {
        releasePointerNote(pointerId);
      }
    }

    function handleKeyboardPointerDown(event) {
      if (event.pointerType === 'mouse' && event.button !== 0) {
        return;
      }

      resizeCanvasForDisplay(keyboardCanvasEl);
      const point = getKeyboardCanvasPointFromEvent(event);
      if (!point) {
        return;
      }

      const note = getKeyboardNoteFromCanvasPosition(point.x, point.y);
      if (typeof note !== 'number') {
        return;
      }

      event.preventDefault();
      if (typeof keyboardCanvasEl.setPointerCapture === 'function') {
        try {
          keyboardCanvasEl.setPointerCapture(event.pointerId);
        } catch (_) {
          // Continue without pointer capture.
        }
      }
      setPointerNote(event.pointerId, note);
    }

    function handleKeyboardPointerMove(event) {
      if (!activePointerNotes.has(event.pointerId)) {
        return;
      }

      resizeCanvasForDisplay(keyboardCanvasEl);
      const point = getKeyboardCanvasPointFromEvent(event);
      const nextNote = point ? getKeyboardNoteFromCanvasPosition(point.x, point.y) : null;
      event.preventDefault();
      setPointerNote(event.pointerId, nextNote);
    }

    function handleKeyboardPointerUp(event) {
      releasePointerNote(event.pointerId);
    }

    function handleMidiMessage(event) {
      const [status, noteNumber, velocity] = event.data;
      const messageType = status & 0xf0;

      if (messageType === 0x90 && velocity > 0) {
        handleNoteOn(noteNumber);
        return;
      }

      if (messageType === 0x80 || (messageType === 0x90 && velocity === 0)) {
        handleNoteOff(noteNumber);
      }
    }

    function bindInputs() {
      for (const input of midiAccess.inputs.values()) {
        input.onmidimessage = handleMidiMessage;
      }
    }

    function renderInputs() {
      if (!midiAccess) {
        inputsListEl.innerHTML = '<li>Not connected.</li>';
        return;
      }
      const inputs = [...midiAccess.inputs.values()];
      if (!inputs.length) {
        inputsListEl.innerHTML = '<li>No MIDI inputs detected.</li>';
        return;
      }
      inputsListEl.innerHTML = inputs
        .map((input) => `<li><strong>${input.name || 'Unknown input'}</strong> <em>(${input.manufacturer || 'Unknown manufacturer'})</em></li>`)
        .join('');
    }

    function updateConnectionStatus() {
      const inputCount = midiAccess ? midiAccess.inputs.size : 0;
      if (!inputCount) {
        setStatus('Connected, but no MIDI inputs are visible.', false);
        setMidiInfo('Laptop keyboard is active. Hardware MIDI input was not detected.');
        return;
      }
      setStatus(`Connected. ${inputCount} MIDI input${inputCount === 1 ? '' : 's'} ready.`, true);
      setMidiInfo('Laptop keyboard and MIDI input are both active.');
    }

    function formatMidiError(error) {
      if (!error) {
        return 'Unknown MIDI error.';
      }
      const name = error.name ? `${error.name}: ` : '';
      const message = error.message || String(error);
      return `${name}${message}`;
    }

    async function requestMidiAccess() {
      try {
        return await navigator.requestMIDIAccess({ sysex: false });
      } catch (error) {
        if (error && error.name === 'TypeError') {
          return navigator.requestMIDIAccess();
        }
        throw error;
      }
    }

    async function connectMidi() {
      if (!('requestMIDIAccess' in navigator)) {
        setStatus('Web MIDI is not supported in this browser.', false);
        setMidiInfo('Use desktop Chrome or Edge on Windows for Web MIDI.');
        return;
      }

      connectBtn.disabled = true;
      setStatus('Requesting MIDI permission...', false);
      setMidiInfo('Allow permission in your browser prompt.');

      try {
        midiAccess = await requestMidiAccess();
        bindInputs();
        renderInputs();
        updateConnectionStatus();
        midiAccess.onstatechange = () => {
          bindInputs();
          renderInputs();
          updateConnectionStatus();
        };
      } catch (error) {
        setStatus('MIDI connection failed.', false);
        setMidiInfo(formatMidiError(error));
      } finally {
        connectBtn.disabled = false;
      }
    }

    function setSettingsOpen(nextOpen) {
      settingsPanelEl.classList.toggle('open', nextOpen);
      settingsPanelEl.setAttribute('aria-hidden', nextOpen ? 'false' : 'true');
      settingsBackdropEl.hidden = !nextOpen;
    }

    function toggleSettingsPanel() {
      setSettingsOpen(!settingsPanelEl.classList.contains('open'));
    }

    function closeSettingsPanel() {
      setSettingsOpen(false);
    }

    function isTypingTarget(target) {
      if (!target) {
        return false;
      }
      const tagName = typeof target.tagName === 'string' ? target.tagName.toLowerCase() : '';
      if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {
        return true;
      }
      return Boolean(target.isContentEditable);
    }

    function handleComputerKeyDown(event) {
      if (event.key === 'Escape') {
        closeSettingsPanel();
        return;
      }

      if (event.defaultPrevented || event.ctrlKey || event.metaKey || event.altKey) {
        return;
      }
      if (isTypingTarget(event.target)) {
        return;
      }

      const key = event.key.toLowerCase();
      const noteNumber = computerKeyToNote.get(key);
      if (typeof noteNumber !== 'number') {
        return;
      }

      event.preventDefault();
      if (heldComputerKeys.has(key)) {
        return;
      }
      heldComputerKeys.add(key);
      handleNoteOn(noteNumber);
    }

    function handleComputerKeyUp(event) {
      const key = event.key.toLowerCase();
      const noteNumber = computerKeyToNote.get(key);
      if (typeof noteNumber !== 'number') {
        return;
      }
      event.preventDefault();
      if (!heldComputerKeys.has(key)) {
        return;
      }
      heldComputerKeys.delete(key);
      handleNoteOff(noteNumber);
    }

    function releaseComputerKeys() {
      if (!heldComputerKeys.size) {
        return;
      }
      for (const key of [...heldComputerKeys]) {
        const noteNumber = computerKeyToNote.get(key);
        if (typeof noteNumber === 'number') {
          handleNoteOff(noteNumber);
        }
      }
      heldComputerKeys.clear();
    }

    function handleSoundToggleChange() {
      setTypingSoundEnabled(typingSoundToggleEl.checked);
    }

    function nextRound() {
      pickNextTarget();
      renderVisuals();
    }

    connectBtn.addEventListener('click', connectMidi);
    settingsToggleEl.addEventListener('click', toggleSettingsPanel);
    settingsCloseEl.addEventListener('click', closeSettingsPanel);
    settingsBackdropEl.addEventListener('click', closeSettingsPanel);
    nextBtnEl.addEventListener('click', nextRound);
    typingSoundToggleEl.addEventListener('change', handleSoundToggleChange);

    window.addEventListener('keydown', handleComputerKeyDown);
    window.addEventListener('keyup', handleComputerKeyUp);
    window.addEventListener('blur', () => {
      releasePointerNotes();
      releaseComputerKeys();
    });
    window.addEventListener('resize', renderVisuals);

    keyboardCanvasEl.style.touchAction = 'none';
    keyboardCanvasEl.style.cursor = 'pointer';
    keyboardCanvasEl.addEventListener('pointerdown', handleKeyboardPointerDown);
    keyboardCanvasEl.addEventListener('pointermove', handleKeyboardPointerMove);
    keyboardCanvasEl.addEventListener('pointerup', handleKeyboardPointerUp);
    keyboardCanvasEl.addEventListener('pointercancel', handleKeyboardPointerUp);
    keyboardCanvasEl.addEventListener('lostpointercapture', handleKeyboardPointerUp);
    keyboardCanvasEl.addEventListener('contextmenu', (event) => event.preventDefault());

    const supportsWebAudio = Boolean(window.AudioContext || window.webkitAudioContext);
    typingSoundToggleEl.checked = false;
    typingSoundToggleEl.disabled = !supportsWebAudio;
    if (!supportsWebAudio) {
      typingSoundToggleEl.title = 'Web Audio is not available in this browser.';
    }

    renderInputs();
    setSettingsOpen(false);
    primeMusicFonts();
    updateStats();
    updateLastPlayed('none');
    pickNextTarget();
    renderVisuals();
  </script>
</body>
</html>
